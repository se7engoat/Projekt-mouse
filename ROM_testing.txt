// WRITE FRAME BUFFER
@0x00   0x00 // Read value to regA
@0x01   0x00 // regA = HCounter
@0x02   0x01 // Read value to regB
@0x03   0x01 // regB = constant 159
@0x04   0x96 // If HCounter = 159 or not?
@0x05   0x0B // Yes, jump to address 0x0B
@0x06   0x54 // Else, update A(=HCounter) +=1
@0x07   0x02 // Write regA to
@0x08   0x00 // regA = HCounter
@0x09   0x07 // Goto address
@0x0A   0x20 // To Write X Y and Pixel data
@0x0B   0x01 // Read value to regB
@0x0C   0x04 // regB = constant 119
@0x0D   0x00 // Read value to regA
@0x0E   0x03 // regA = VCounter
@0x0F   0x96 // If VCounter = 119 or not?
@0x10   0x1A // Yes, jump to address 0x1A
@0x11   0x54 // No, A(=VCounter) +=1
@0x12   0x02 // Write regA to
@0x13   0x03 // regA = VCounter
@0x14   0x00 // Read value to regA
@0x15   0x02 // regA = constant 0
@0x16   0x02 // Write regA to
@0x17   0x00 // HCounter (= 0)
@0x18   0x07 // Goto address
@0x19   0x20 // To Write X Y and Pixel data
@0x1A   0x00 // Read value to regA
@0x1B   0x02 // regA = constant 0
@0x1C   0x02 // Write regA to
@0x1D   0x03 // VCounter = 0 (Finish scan, reset)
@0x1E   0x02 // Write regA to
@0x1F   0x00 // HCounter = 0
@0x20   0x00 // Read value to regA
@0x21   0x03 // regA = VCounter
@0x22   0x01 // Read value to regB
@0x23   0x12 // regB = constant 40
@0x24   0x96 // Check if VCounter = 40
@0x25   0x30 // Jump to address 0x30
@0x26   0x01 // Read value to regB
@0x27   0x13 // regB = constant 80
@0x28   0x96 // Check if VCounter = 80
@0x29   0x30 // Jump to address 0x30
@0x2A   0x01 // Read value to regB
@0x2B   0x02 // regB = constant 1
@0x2C   0x03 // Write regB to
@0x2D   0xB2 // Address 0xB2
@0x2E   0x07 // Goto
@0x2F   0x36 // Address 0x36
@0x30   0x01 // Read value to regB
@0x31   0x05 // regB = constant 0
@0x32   0x03 // Write regB to
@0x33   0xB2 // Address 0xB2
@0x34   0x07 // Goto
@0x35   0x4A // Address 0x4A

// Character Mapping (F, L, R, B, I)
@0x36   0x0F // F (HEX_OUT = 7'b0001110) => 4'b1100
@0x37   0x07 // L (HEX_OUT = 7'b1000111) => 4'b1010
@0x38   0x0B // R (HEX_OUT = 7'b0101111) => 4'b1011
@0x39   0x1F // B (HEX_OUT = 7'b0011111) => 4'b1101
@0x3A   0x0D // I (HEX_OUT = 7'b1110111) => custom if needed (default OFF)

// Display combinations (For multiple segments)
@0x3B   0x3F // FL (combination of F and L)
@0x3C   0x1F // FR (combination of F and R)
@0x3D   0x3F // LR (combination of L and R)
@0x3E   0x2F // LB (combination of L and B)
@0x3F   0x1F // RB (combination of R and B)

// WRITE COMMAND TO IR AND LEDS
@0xD9   0x02 // Write command from reg A to IR memory
@0xDA   0x90
@0xDB   0x02 // Write command from reg A to LED memory high address
@0xDC   0xC1
@0xDD   0x08 // Go to IDLE


// INTERRUPT JUMPS
@0xFE   0x85 // Timer interrupt address
@0xFF   0x5C // Mouse interrupt address

