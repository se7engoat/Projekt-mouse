// WRITE FRAME BUFFER
@0x00   0x00    // Read value to regA
@0x01   0x00    // regA = HCounter

@0x02   0x01    // Read value to regB
@0x03   0x01    // regB = constant 159
@0x04   0x96    // If HCounter == 159 ?
@0x05   0x0B    // Yes, jump to address 0x0B

@0x06   0x54    // No, A = A + 1
@0x07   0x02    // Write regA to
@0x08   0x00    // HCounter
@0x09   0x07    // Goto address
@0x0A   0x20    // Continue to pixel write section

@0x0B   0x01    // Read value to regB
@0x0C   0x04    // regB = constant 119
@0x0D   0x00    // Read value to regA
@0x0E   0x03    // regA = VCounter
@0x0F   0x96    // If VCounter == 119 ?
@0x10   0x1A    // Yes, jump to address 0x1A

@0x11   0x54    // No, A = A + 1
@0x12   0x02    // Write regA to
@0x13   0x03    // VCounter
@0x14   0x00    // Load 0 to regA
@0x15   0x02
@0x16   0x02    // Write regA to
@0x17   0x00    // HCounter = 0
@0x18   0x07    // Goto
@0x19   0x20    // Continue to pixel write section

@0x1A   0x00    // Load 0 to regA
@0x1B   0x02
@0x1C   0x02    // Write regA to
@0x1D   0x03    // VCounter = 0
@0x1E   0x02    // Write regA to
@0x1F   0x00    // HCounter = 0

// PIXEL DATA WRITING
@0x20   0x00    // Read regA = VCounter
@0x21   0x03
@0x22   0x01    // Load regB = 40
@0x23   0x12
@0x24   0x96    // VCounter == 40 ?
@0x25   0x30    // Yes, jump to @0x30

@0x26   0x01    // Load regB = 80
@0x27   0x13
@0x28   0x96    // VCounter == 80 ?
@0x29   0x30    // Yes, jump to @0x30

@0x2A   0x01    // Load regB = 1
@0x2B   0x02
@0x2C   0x03    // Write regB to
@0x2D   0xB2    // VGA pixel data
@0x2E   0x07    // Goto
@0x2F   0x36    // Check X range

@0x30   0x01    // Load regB = 0
@0x31   0x05
@0x32   0x03    // Write regB to
@0x33   0xB2    // VGA pixel data = 0
@0x34   0x07    // Goto
@0x35   0x4A    // Write X, Y, Pixel

// X RANGE CHECK
@0x36   0x00    // Load regA = HCounter
@0x37   0x00
@0x38   0x01    // Load regB = 53
@0x39   0x10
@0x3A   0x96    // HCounter == 53 ?
@0x3B   0x46    // Jump if yes

@0x3C   0x01    // Load regB = 107
@0x3D   0x11
@0x3E   0x96    // HCounter == 107 ?
@0x3F   0x46    // Jump if yes

@0x40   0x01    // Load regB = 1
@0x41   0x02
@0x42   0x03    // Write to VGA pixel data
@0x43   0xB2
@0x44   0x07    // Goto
@0x45   0x4A

@0x46   0x01    // Load regB = 0
@0x47   0x05
@0x48   0x03    // Write to VGA pixel data
@0x49   0xB2

// WRITE X Y TO VGA ADDR
@0x4A   0x00    // regA = HCounter
@0x4B   0x00
@0x4C   0x02    // Write to VGA X addr
@0x4D   0xB0

@0x4E   0x01    // regB = VCounter
@0x4F   0x03
@0x50   0x03    // Write to VGA Y addr
@0x51   0xB1

// CONDITIONAL LOOP BACK
@0x52   0x01    // Load max HCounter to regB
@0x53   0x01
@0x54   0xB6    // If curr HCounter < max
@0x55   0x00    // Loop to 0x00

@0x56   0x00    // Load VCounter to regA
@0x57   0x03
@0x58   0x01    // Load max VCounter to regB
@0x59   0x04
@0x5A   0xB6    // If curr VCounter < max
@0x5B   0x00    // Loop to 0x00

// =========================
// MOUSE INIT
// =========================
@0x5C   0x00    // Read mouse status byte from memory to regA
@0x5D   0xA0

@0x5E   0x02    // Write mouse status byte to LED memory
@0x5F   0xC0

@0x60   0x00    // Read previous mouse X
@0x61   0x14

@0x62   0x01    // Read previous mouse Y
@0x63   0x15

@0x64   0x02    // Write previous X to VGA X
@0x65   0xB0

@0x66   0x03    // Write previous Y to VGA Y
@0x67   0xB1

@0x68   0x00    // Load previous pixel value to regA
@0x69   0x16

@0x6A   0x02    // Restore pixel value to VGA pixel memory
@0x6B   0xB2

@0x6C   0x00    // Read current Mouse X
@0x6D   0xA1

@0x6E   0x01    // Read current Mouse Y
@0x6F   0xA2

@0x70   0x02    // Save Mouse X to RAM
@0x71   0x14

@0x72   0x03    // Save Mouse Y to RAM
@0x73   0x15

@0x74   0x02    // Write Mouse X to 7-segment base address
@0x75   0xD0

@0x76   0x03    // Write Mouse Y to 7-segment high address
@0x77   0xD1

@0x78   0x02    // Write Mouse X to VGA X
@0x79   0xB0

@0x7A   0x03    // Write Mouse Y to VGA Y
@0x7B   0xB1

@0x7C   0x00    // Read current pixel value from VGA
@0x7D   0xB2

@0x7E   0x02    // Save current pixel value to RAM
@0x7F   0x16

@0x80   0x00    // Load constant 1 to regA
@0x81   0x05

@0x82   0x02    // Set VGA pixel value = 1 (draw mouse)
@0x83   0xB2

@0x84   0x08    // Go to IDLE


// ==============================
// DETERMINE WHICH GRID SQUARE
// ==============================
@0x85   0x00    // Load Mouse X to regA
@0x86   0xA1

@0x87   0x01    // Load 53 to regB
@0x88   0x10

@0x89   0xB6    // If X < 53, branch
@0x8A   0x91

@0x8B   0x01    // Load 107 to regB
@0x8C   0x11

@0x8D   0xB6    // If X < 107, branch
@0x8E   0x9D

@0x8F   0x07    // Else, jump to right region
@0x90   0xA9


// ---- X < 53 (Left) ----
@0x91   0x00    // Load Mouse Y to regA
@0x92   0xA2

@0x93   0x01    // Load 40 to regB
@0x94   0x12

@0x95   0xB6    // If Y < 40 → Bottom Left
@0x96   0xB5

@0x97   0x01    // Load 80 to regB
@0x98   0x13

@0x99   0xB6    // If Y < 80 → Middle Left
@0x9A   0xCD

@0x9B   0x07    // Else → Top Left
@0x9C   0xC1


// ---- 53 ≤ X < 107 (Middle) ----
@0x9D   0x00    // Load Mouse Y to regA
@0x9E   0xA2

@0x9F   0x01    // Load 40 to regB
@0xA0   0x12

@0xA1   0xB6    // If Y < 40 → Bottom Middle
@0xA2   0xBD

@0xA3   0x01    // Load 80 to regB
@0xA4   0x13

@0xA5   0xB6    // If Y < 80 → Middle Middle
@0xA6   0xD5

@0xA7   0x07    // Else → Top Middle
@0xA8   0xC9


// ---- X ≥ 107 (Right) ----
@0xA9   0x00    // Load Mouse Y to regA
@0xAA   0xA2

@0xAB   0x01    // Load 40 to regB
@0xAC   0x12

@0xAD   0xB6    // If Y < 40 → Bottom Right
@0xAE   0xB9

@0xAF   0x01    // Load 80 to regB
@0xB0   0x13

@0xB1   0xB6    // If Y < 80 → Middle Right
@0xB2   0xD1

@0xB3   0x07    // Else → Top Right
@0xB4   0xC5


// =========================
// SELECT DIRECTION
// =========================
// Bottom Left
@0xB5   0x00    // Read command from RAM
@0xB6   0x17
@0xB7   0x07    // Jump to IR + LED write
@0xB8   0xD9

// Bottom Right
@0xB9   0x00
@0xBA   0x18
@0xBB   0x07
@0xBC   0xD9

// Bottom Middle
@0xBD   0x00
@0xBE   0x19
@0xBF   0x07
@0xC0   0xD9

// Top Left
@0xC1   0x00
@0xC2   0x20
@0xC3   0x07
@0xC4   0xD9

// Top Right
@0xC5   0x00
@0xC6   0x21
@0xC7   0x07
@0xC8   0xD9

// Top Middle
@0xC9   0x00
@0xCA   0x22
@0xCB   0x07
@0xCC   0xD9

// Middle Left
@0xCD   0x00
@0xCE   0x23
@0xCF   0x07
@0xD0   0xD9

// Middle Right
@0xD1   0x00
@0xD2   0x24
@0xD3   0x07
@0xD4   0xD9

// Middle Middle
@0xD5   0x00
@0xD6   0x25
@0xD7   0x07
@0xD8   0xD9


// =========================
// WRITE COMMAND TO IR & LED
// =========================
@0xD9   0x02    // Write to IR
@0xDA   0x90

@0xDB   0x02    // Write to LED high address
@0xDC   0xC1

@0xDD   0x08    // Go to IDLE


// =========================
// INTERRUPT VECTORS
// =========================
@0xFE   0x85    // Timer interrupt → Determine grid square
@0xFF   0x5C    // Mouse interrupt → Mouse init
